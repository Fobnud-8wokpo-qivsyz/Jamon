____________________________________________________SMB_______________________________________________________________________

Imprimir desde la Linea de Comandos en una impresora compartida en red:
#echo -en "\rHello\r\f" | smbclient "//192.9.200.165/MULTIPROPOSITO" "password" -c "print -" -N -U "username" -W "workgroup"




_________________________________________________update-rc.d___________________________________________________________________

El comando update-rc.d nos permite automatizar el proceso de creación y borrado de enlaces 
a los scripts de inicio, con en fin de iniciar/parar servicios.

#update-rc.d -f nombre_proceso remove          //eliminar servicios del proceso de arranque
#update-rc.d -f squid remove

#update-rc.d nombre_proceso defaults          //crear enlaces usando parámetros por defecto
#update-rc.d ssh defaults                     //ejemplo 1
#update-rc.d networking defaults              //ejemplo 2
#/etc/init.d/networking restart


__________________________________________________SSH authentication___________________________________________________________

//chequeamos la configuracion /etc/ssh/sshd_config
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
//Si en lugar de DSA se utilizan claves RSA, será necesario además descomentar la línea:
RSAAuthentication yes


#ssh-keygen -t [rsa-dsa-ecdsa-rsa1-ed25519]
#ls -lath    //revisamos siempre los permisos de las claves generadas. deben ser restrctivos para cada usuario.
copiamos la clave publica generada al archivo authorized_keys del sistema remoto:
si no existe el archivo autohrized_keys lo creamos:
#touch authorized_keys
#chmod 644 authorized_keys
#cat .ssh/id_dsa.pub | ssh root@sysremoto "cat >> .ssh/authorized_keys" //opcion 1 copiado
#ssh user@syslocal "cat .ssh/id_dsa.pub" >> .ssh/authorized_keys        //opcion 2 si el usuario tiene un ssh levantado me copio su clave
#scp id_rsa.pub root@sysremoto:/root/.ssh && cat id_rsa.pub >> authorized_keys    //opcion 3 copia manual

__________________________________________________SQL basic____________________________________________________________________

show databases;
use agendaDB;
show tables;
create table ejemplo(
numero int,
nombre varchar(50),
apellido varchar(50),
primary key (numero),
);
describe ejemplo;
select nombre,apellido from agenda;
insert into ejemplo values(1,'esteban','quito');
delete from ejemplo where numero = 1;



___________________________________________________CHROOT______________________________________________________________________

apt-get install debootstrap
//vamos a necesitar tener una particion extra. por ejemplo /sdb1
mkdir /media/Debian
mount /dev/sdb1 /media/Debian
//si queremos instalar wheezy para arquitectura 386
debootstrap --arch i386 wheezy /media/Debian http://ftp.fr.debian.org/debian
chroot /media/Debian /bin/bash
//instalamos el Kernel. antes chequeamos y editamos las sources.list
nano /etc/sources.list
apt-get update && apt-get upgrade
//buscamos un kernel que nos satisfaga
aptitude search linux-image-
apt-get install 'el kernel que hayamos elejido'


Escaping Linux Chroot

#adduser prisoner
#gpasswd -a prisoner root
#mkdir chroot
#cd chroot
#mkdir bin dev  etc home  home/prisoner  lib  var  usr  usr/bin
#cp /bin/bash /chroot/bin
//To make sure that the bash shell will work properly we need to locate its necessary 
//libraries and copying them to /lib jail folder:  
//listamos las librerias asociadas al bash
#ldd /bin/bash
ejemplo resultado del comando ldd:
        linux-vdso.so.1 (0x00007ffcb1fed000)
        libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007fafe891f000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fafe871b000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fafe837c000)
        /lib64/ld-linux-x86-64.so.2 (0x0000559e26c9e000)
//copiamos todas las librerias que nos listo el anterior cmd a /chroot/lib
#cp /lib/.......... /chroot/lib        
//Ahora ejecutaremos el preciado chroot (en caso de que tengamos el siguiente error:
//chroot: failed to run command ‘/bin/bash’ no such file or directory
//Solution: [Enlace simbolico] # ln -s lib /chroot/lib64 (porque? http://bit.ly/2weXyO6)

//Escaping the jail:

IN PROCESS::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


___________________________________________________KERNEL______________________________________________________________________

#aptitude search linux-image-                      //ver los kernels disponibles
#apt-get install 'el kernel que elijamos'



___________________________________________________DNS-hostname-domainname-fqdn________________________________________________

#nslookup 192.168.1.10
#dig casita.com
#dig -x 192.168.1.10
#host 192.168.1.10
#host -t NS -T parrot.casita.com
#hostname
#domainname

Para asignar el fqdn, añadimos esta linea al archivo etc/hosts que es el que lee init.d/hostname.sh para configurar el fqdn:
#echo "127.0.0.1 mipc.localhost.com mipc localhost" > /etc/hosts


Your hostname is the name of your computer.
Your fully qualified domain name is your hostname plus the domain your company uses often ending in .local.
So if the name of your computer is bob, and your company's domain is contoso.local, your computer's fully qualified domain name (FQDN) is bob.contoso.local:
    Hostname: bob
    Domain: contoso.com
    FQDN: bob.contoso.com

#bind9          

/etc/bind/named.conf 
                   __> named.conf.options
                   __> named.conf.local
                   __> db.127
                   __> db.root
                   
                   
---------------------------------
                                |
                                |Ejemplo para dominio casita.com
                                |
                                >>> named.conf.local
zone "casita.com" {
      type master;
      file "/etc/bind/zones/db.casita.com";
      };

zone "10.168.192.in-addr.arpa" {
      type master;
      file "/etc/bind/zones/rev.10.168.192.in-addr.arpa";
      };
---------------------------------
                                |
                                |mkdir zones & cp db.local zones/db.casita.com & cp db.127 zones/rev.10.168.192.in-addr.arpa
                                |
                                >>> nano db.casita.com
;
; BIND data file for local loopback interface
;
$TTL    604800
@       IN      SOA     casita.com. root.casita.com. (
                              2         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@       IN      NS      mimaquina.casita.com.
mimaquina        IN      A       192.9.200.75

---------------------------------
                                |
                                |
                                |
                                >>> nano rev.10.168.192.in-addr.arpa
;
; BIND reverse data file for local loopback interface
;
$TTL    604800
@       IN      SOA     casita.com. root.casita.com. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@       IN      NS      mimaquina.casita.com.
75      IN      PTR     mimaquina.


---------------------------------
                                |
                                |
                                |
                                >>> nano /etc/bind/named.conf.options
 forwarders {
      208.67.222.222;
      208.67.220.220;
};

--------------------------------->>> /etc/init.d/bind9 restart
--------------------------------->>> /etc/resolv.conf 
nameserver 192.9.200.75
nameserver 8.8.8.8

                
                                
                                

___________________________________________________Cipher_Keys_and others_____________________________________________________

Simetrico
1.  gpg -c supersecreto.txt      //cifrado
1.b gpg -d supersecreto.txt.gpg  //descrifrado

Asimetrico
1.  gpg --gen-key   //elegimos el algoritmo para generar clave.longitud de clave.contraseña de priv-key.Id de usuario.
2.  gpg -k          //visualizar keyring
2.b gpg -kv         //visualizar keyring
2.c gpg --list-public-keys
2.d gpg --list-secret-keys
2.e gpg --fingerprint       //listar con huellas de las claves
2.f gpg --list-sigs         //ver la firma de cada clave
2.g gpg --edit-key          //editar una clave (fecha de caducidad.añadir huella.firmar la clave)
3.  gpg -a --export id_usuario    //visualizar la clave en formato ASCII

Para guardar/exportar nuestra clave publica a un archivo podemos usar alguno de estos 3 comandos donde miclave.asc es el nombre
del archivo en el que guardaremos nuestra clave:

4. gpg -a --export -o miclave.asc key_id
5. gpg -a --export --output miclave.asc key_id
6. gpg -a --export key_id > miclave.asc

Para importar a nuestro keyring la clave publica de otra persona:
7. gpg --import clavepublica.asc

Para firmar un documento:
8. gpg -sb -a documentoafirmar   /nos pedira nuestra contraseña de clave privada y generara documentoafirmar.asc
9. gpg hello.txt.asc             /teniendo el hello.txt + hello.txt.asc corroboramos la firma del mismo

Para exportar nuestra clave privada:
10. gpg --export-secret-key -a id_key > private.key

Para importar clave privada
11. gpg --import private.key
12. gpg --allow-secret-key-import --import private.key    //esta 2 opcion para importar es considerada +segura

Borrar una clave publica/privada
13. gpg --delete-key id_key
14. gpg --delete-secret-key id_key

Encriptar archivos:
15.  gpg -e archivo_a_encriptar  //encripta con la clave publica por defecto
15.a gpg --encrypt --recipient id_key archivo_a_encriptar
16.  gpg -er 'clave_publica_destinatario' archivo_a_encriptar
17.  gpg -a -er 'clave_publica_destinatario' archivo_a_encriptar  //encripta con 7-bit ASCII

Subir/exportar la clave publica a un servidor de claves:
18. gpg --send-keys --keyserver pgp.mit.edu id_key

Bajar/importar clave desde un servidor:
19. gpg --keyserver pgp.mit.edu --recv-keys id_key


20. OPENSSL

Generar un certificado con openssl
#openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert



___________________________________________________Analisis de procesos y monitoreo del sistema________________________________

1. uptime → hora.fecha.usuarios conectados
2. top    → info detallada de los procesos.memoria.cpu.hora.etc...
3. watch -n1 -d free → mostrar uso de memoria
4. vmstat → info sobre el uso de virtual mem por threads del nucleo.disco.procesador
5. time → tiempo de ejecución del código de un programa por parte del procesador
6. ps → procesos lanzados en el sistema por el usuario
7. free → uso de la memorio fisica y swap
8. df → examina el sistema de ficheros
9.  du → capacidad ocupada por un sistema en concreto
10. hdparm → conocer y cambiar parametros de un disco
11. w → info de usuarios conectados a la maquina
12. mpstat → info de rendimiento de cada procesador del sistema
13. iostat → info de actividad del CPU y de dispositivos de E/S
13.a sockstat → info de procesos y sockets usados

13.b lsof -Pni :4444   → Ejemplo de busqueda de Info sobre proceso escuchando en el puerto 4444
Nos impimiria en pantalla:

COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
nc      3282 root    3u  IPv4  35693      0t0  TCP *:4444 (LISTEN)


14. sar → Consta de dos órdenes complementarias:
Algunos parámetros son:
u: utilización del procesador
B: paginación de memoria virtual
c: creación de procesos
b: transferencias con E/S
d: transferencias por cada disco
I: sistema de interrupciones
n: conexión de 
q: carga media del sistema
r: sistema de memoria
w: cambios de contexto
W: intercambio 
(swapping)
14.b sadc(system activity data collector): recoge los datos relacionados con el sistema y construye con ellos un registro en formato binario.
14.c sar (system activity reader): recopila datos en formato texto o binario y permite leer los datos binarios recogidos por sadc, y los traduce a formato texto.

15.at 3pm  → el comando 'at' permite correr procesos en un tiempo definido

                                                                      
___________________________________________________Información del sistema_____________________________________________________

1. arch → mostrar la arquitectura de la máquina (1).
2. uname -m → mostrar la arquitectura de la máquina (2).
3. uname -r → mostrar la versión del kernel usado.
4. uname -a → mostrar la información completa.
4.1 uname -mars 
5. cat /etc/issue → mostrar el nombre de la distribución
5.1 cat /etc/*-release → Info sobre la distribucion
6. dmidecode -q → mostrar los componentes (hardware) del sistema.
7. hdparm -i /dev/hda → mostrar las características de un disco duro.
8. hdparm -tT /dev/sda → realizar prueba de lectura en un disco duro.
9. cat /proc/cpuinfo → mostrar información de la CPU.
10.cat /proc/interrupts → mostrar las interrupciones.
11.cat /proc/meminfo → verificar el uso de memoria.
12.cat /proc/swaps → mostrar ficheros swap.
13.cat /proc/version → mostrar la versión del kernel.
14.cat /proc/net/dev → mostrar adaptadores de red y estadísticas.
15.cat /proc/mounts → mostrar el sistema de ficheros montado.
15A.cat /etc/services → mostrar servicios
16.lspci -tv → mostrar los dispositivos PCI.
17.lsusb -tv → mostrar los dispositivos USB.
18.lshw → listar el hardware.
19.discover → listar el hardware.
20.date → mostrar la fecha del sistema.
21.cal 2011 → mostrar el almanaque de 2011.
22.cal 07 2011 → mostrar el almanaque para el mes julio de 2011.
23.date 041217002011.00 → colocar (declarar, ajustar) fecha y hora.
24.clock -w → guardar los cambios de fecha en la BIOS.
25.blkid → mostrar información (nombre, etiqueta, UUID, tipo de partición) sobre los
dispositivos de bloque (discos rígidos, etc.)
26.echo $DESKTOP_SESSION           → mostrar the windows manager terminal

 
______________________________________________________Apagar, reiniciar o cerrar sesión________________________________________


1. shutdown -h now → apagar el sistema (1).
2. init 0 → apagar el sistema (2).
3. telinit 0 → apagar el sistema (3).
4. halt → apagar el sistema (4).
5. shutdown -h hours:minutes & → apagado planificado del sistema.
6. shutdown -c → cancelar un apagado planificado del sistema.
7. shutdown -r now → reiniciar (1).
8. reboot → reiniciar (2).
9. logout → cerrar sesión.
10.skill nombre_de_usuario → cerrar sesión (2) [Es preciso ejecutarlo con privilegios de root]
11.exit → salir del intérprete de comandos (si solo hay uno, equivale a cerrar sesión).

___________________________________________________________Gestionar archivos y directorios____________________________________

1. cd → ir al directorio personal.
2. cd /home → cambiar al directorio “/home”.
3. cd .. → retroceder un nivel.
4. cd ../.. → retroceder 2 niveles.
5. cd ~user1 → ir al directorio user1.
6. cd - → ir (regresar) al directorio anterior.
7. pwd → mostrar el camino del directorio actual.
8. ls → listar el contenido de un directorio.
9. ls -F → listar el contenido de un directorio (distinguiendo los directorios con una barra)
10. ls -l → listar el contenido de un directorio, mostrando los detalles.
11. ls -lh → listar el contenido de un directorio, mostrando los detalles (y el tamaño en un
formato “humanizado”).

12. ls -a → listar el contenido de un directorio, incluendo los ficheros ocultos.
13. ls *[0-9] → listar los ficheros y carpetas que contienen números.
14. ls -laR | less → listar recursivamente el contenido del directorio actual y todos los
subdirectorios y archivos, incluyendo los ocultos, separados por página.
14A. ls -lhgo → listar con (l)listado largo, (h)formato entendible, (g)sin mostrar grupo, (o)sin mostrar dueño
14B. ls -lhgoR → lo mismo anterior + RECURSIVE
15. tree → mostrar los ficheros y carpetas en forma de árbol comenzando por la raíz.(1)
16. lstree → mostrar los ficheros y carpetas en forma de árbol comenzando por la raíz.(2)
17. mkdir dir1 → crear un directorio de nombre ‘dir1′.
18. mkdir dir1 dir2 → crear dos directorios a la vez (en la ubicación actual).
19. mkdir -p /tmp/dir1/dir2 → crear una estructura de directorios, si no existe.
20. rm file1 → eliminar el archivo ‘file1′.
21. rm -f file1 → eliminar el archivo ‘file1′ en modo forzado.
22. rmdir dir1 → borrar el directorio ‘dir1′.
 
23. rm -rf dir1 → eliminar recursivamente y en modo forzado el directorio ‘dir1′ con todo lo
que contenga.

24. rm -rf dir1 dir2 → borrar dos directorios con su contenido de forma recursiva.
25.mv dir1 new_dir → renombrar o mover un fichero o carpeta (directorio).
26.cp file1 destino/ → copiar un fichero al destino elegido.
27.cp file1 file2 destino/ → copiar a la vez dos ficheros a un mismo directorio.
28.cp file1 file2 → copiar file1 en file2.
29.cp dir /* . → copiar todos los ficheros de un directorio dentro del directorio de trabajo
actual.

30.cp -a /tmp/dir1 . → copiar un directorio dentro del directorio actual de trabajo.
31.cp -a dir1 → copiar un directorio.
32.cp -a dir1 dir2 → copiar dos directorio al unísono.
33.ln -s file1 lnk1 → crear un enlace simbólico al fichero o directorio.
34.ln file1 lnk1 → crear un enlace físico al fichero o directorio.
35.touch file1 → actualizar la fecha de modificación de file1, o crearlo si no existe.
36.touch -t 0712250000 file1 → modificar el tiempo real (tiempo de creación) de un fichero o
directorio.

37.file file1 → salida (volcado en pantalla) del tipo mime de un fichero texto.
38.iconv -l → listas de cifrados conocidos.
39.iconv -f fromEncoding -t toEncoding inputFile > outputFile → crea una nueva forma del fichero
de entrada asumiendo que está codificado en fromEncoding y convirtiéndolo a
ToEncoding.



____________________________________________________________BUSCAR ARCHIVOS/FILES:_____________________________________________


1. find / -name file1                 → buscar fichero y directorio a partir de la raíz del sistema.
2. find / -user user1                 → buscar ficheros y directorios pertenecientes al usuario ‘user1′.
3. find /home/user1 -name \*.bin      → buscar ficheros con extensión ‘. bin’ dentro del directorio ‘/home/user1′.
4. find /usr/bin -type f -atime +100  → buscar ficheros binarios no usados en los últimos 100 días.
5. find /usr/bin -type f -mtime -10   → buscar ficheros creados o cambiados dentro de los últimos 10 días.
6. find / -name \*.rpm -exec chmod 755 '{}' \; → buscar ficheros con extensión ‘.rpm’ y modificar permisos.
7. find . -type f -print0 | xargs -0 chmod 644 → modificar recursivamente los permisos a todos los ficheros bajo el directorio actual.
8. find / -xdev -name \*.rpm → Buscar ficheros con extensión ‘.rpm’ ignorando los dispositivos removibles como cdrom, pen-drive, etc.…
9. find . -maxdepth 1 -name *.jpg -print -exec convert ”{}” -resize 80×60 “thumbs/{}” \; → agrupar ficheros redimensionados en el directorio actual y enviarlos a directorios en vistas de
miniaturas (requiere convertir desde ImagemagicK).

10.find /tmp/dir1 -depth -regextype posix-extended -regex '.*(\s+|:+|\\+|>+|<+|”+|\*+|\?+|\|+).*'
-execdir rename 's/(\s+|:+|\\+|>+|<+|”+|\*+|\?+|\|+)/_/g' ”{}” \; → renombrar recursivamente todos los directorios y ficheros bajo ‘/tmp/dir1′, cambiando los espacios y otros
caracteres extraños por guiones bajos.

11.locate \*.ps → encuentra ficheros con extensión ‘.ps’ ejecutados primeramente con el command ‘updatedb’.

12.whereis halt → mostrar la ubicación de un fichero binario, de ayuda o fuente. En este caso pregunta dónde está el comando ‘halt’.

13.which comando → mostrar la ruta completa a un comando/binario. 

14.find /etc/ -name "issue*"  →"busca por nombre"
15.find / -perm 777           →"busca por permisos"
16.find / -user root          →"busca por usuario"

17.find /dir/to/search -type f -exec sh -c 'file -b {} | grep text &>/dev/null' \; -print    →"buscar archivos humman-readables"

18.find -type f -size 1033c -exec sh -c 'file -b {} | grep text &>/dev/null' \; -print 
"buscar archivos hummand-readables con un tamaño especifico, ejemplo: 1033 bytes
As units you can use:
    b – for 512-byte blocks (this is the default if no suffix is used)
    c – for bytes
    w – for two-byte words
    k – for Kilobytes (units of 1024 bytes)
    M – for Megabytes (units of 1048576 bytes)
    G – for Gigabytes (units of 1073741824 bytes)
    
    
    

________________________________________________________________Montando un sistema de ficheros________________________________

1. mount /dev/hda2 /mnt/hda2 → montar un disco llamado hda2. Verifique primero la
existencia del directorio ‘/ mnt/hda2′; si no está, debe crearlo.

2. umount /dev/hda2 → desmontar un disco llamado hda2. (Antes es necesario salir del
punto ‘/mnt/hda2′.

3. fuser -km /mnt/hda2 → forzar el desmontaje cuando el dispositivo está ocupado.
4. umount -n /mnt/hda2 → correr el desmontaje sin leer el fichero /etc/mtab. Útil cuando el
fichero es de solo lectura o el disco duro está lleno.

5. mount /dev/fd0 /mnt/floppy → montar un disco flexible (floppy).
6. mount /dev/cdrom /mnt/cdrom → montar un cdrom / dvdrom.
7. mount /dev/hdc /mnt/cdrecorder → montar un cd regrabable o un dvdrom.
8. mount /dev/hdb /mnt/cdrecorder → montar un cd regrabable / dvdrom (un dvd).
9. mount -t udf,iso9660 -o loop file.iso /mnt/cdrom → montar un fichero de imagen de un medio
óptico (como un CD o DVD en formato ISO).

10.mount -t vfat /dev/hda5 /mnt/hda5 → montar un sistema de ficheros FAT32.
11.mount -t ntfs-3g /dev/hda5 /mnt/hda5 → montar un sistema de ficheros NTFS.
12.mount /dev/sda1 /mnt/usbdisk → montar un usb pen-drive o una memoria (sin especificar el
tipo de sistema de ficheros).

 
____________________________________________________________________Espacio en disco__________________________________________

1. lsblk  → muestra todos los dispositivos conectados junto con sus esquemas de particionado
1. lsscsi
1. fdisk -l
1. df -h → mostrar una lista de las particiones montadas.
2. ls -lSr | more → mostrar el tamaño de los ficheros y directorios ordenados por tamaño.
3. du -sh dir1 → Estimar el espacio usado por el directorio ‘dir1′.
4. du -h --max-depth=1 | sort -nr → mostrar en orden descendente el tamaño de todos los
subdirectorios en la ubicación actual.

5. du -sk * | sort -rn → mostrar el tamaño de los ficheros y directorios ordenados por tamaño.
6. rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n → mostrar el espacio usado por los
paquetes rpm instalados organizados por tamaño (Fedora, Redhat y otros).

7. dpkg-query -W -f='${Package}\t${Installed-Size}\n' | sort -k 2 -nr | grep -v deinstall | head -n 25 |
awk '{printf ”%.3f MB\t%s\n”, $2/(1024), $1}‘ → mostrar (en Debian o derivadas) un listado con los 25 paquetes 
instalados que más espacio consumen (en orden descendente).


 ______________________________________________________Usuarios y grupos______________________________________________________

1. groupadd nombre_del_grupo → crear un nuevo grupo.
2. groupdel nombre_del_grupo → borrar un grupo.
3. groupmod -n nuevo_nombre_del_grupo viejo_nombre_del_grupo → renombrar un grupo.
4. useradd -c “Name Surname ” -g admin -d /home/user1 -s /bin/bash user1 → Crear un nuevo usuario perteneciente al grupo “admin”.

5. useradd user1 → crear un nuevo usuario.
6. userdel -r user1 → borrar un usuario (‘-r’ elimina el directorio Home).
7. usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 → cambiar los atributos del
usuario.

8. usermod -aG sudoers,plugdev user1 → agregar el usuario user1 a dos grupos existentes, para incrementar sus permisos (en este caso, agregar la posibilidad de conectar
dispositivos y ejecutar comandos como superusuario)

9. passwd → cambiar contraseña.
10.passwd user1 → cambiar la contraseña de un usuario (solamente por root).
11.chage -E 2011-12-31 user1 → colocar un plazo para la contraseña del usuario. En este caso
dice que la clave expira el 31 de diciembre de 2011.

12.pwck → chequear la sintaxis correcta el formato de fichero de ‘/etc/passwd’ y la
existencia de usuarios.

13.grpck → chequear la sintaxis correcta y el formato del fichero ‘/etc/group’ y la existencia
de grupos.

14.newgrp group_name → registra a un nuevo grupo para cambiar el grupo predeterminado
de los ficheros creados recientemente.

 
 
 
______________________________Permisos en ficheros (usar “+” para colocar permisos y “-” para eliminar)_______________________

1. ls -lh → Mostrar permisos.
2. ls /tmp | pr -T5 -W$COLUMNS → dividir la terminal en 5 columnas.
3. chmod ugo+rwx directory1 → colocar permisos de lectura ®, escritura (w) y ejecución(x) al
propietario (u), al grupo (g) y a otros (o) sobre el directorio ‘directory1′.

4. chmod go-rwx directory1 → quitar permiso de lectura ®, escritura (w) y (x) ejecución al
grupo (g) y otros (o) sobre el directorio ‘directory1′.

5. chown user1 file1 → cambiar el dueño de un fichero.
6. chown -R user1 directory1 → cambiar el propietario de un directorio y de todos los ficheros
y directorios contenidos dentro.

7. chgrp group1 file1 → cambiar grupo de ficheros.
8. chown user1:group1 file1 → cambiar usuario y el grupo propietario de un fichero.
9. find / -perm -u+s → visualizar todos los ficheros del sistema con SUID configurado.
10.chmod u+s /bin/file1 → colocar el bit SUID en un fichero binario. El usuario que corriendo
ese fichero adquiere los mismos privilegios como dueño.

11.chmod u-s /bin/file1 → deshabilitar el bit SUID en un fichero binario.
12.chmod g+s /home/public → colocar un bit SGID en un directorio –similar al SUID pero por
directorio.

13.chmod g-s /home/public → desabilitar un bit SGID en un directorio.
14.chmod o+t /home/public → colocar un bit STIKY en un directorio. Permite el borrado de
ficheros solamente a los dueños legítimos.

15.chmod o-t /home/public → desabilitar un bit STIKY en un directorio.




__________________________Atributos especiales en ficheros (usar “+” para colocar permisos y “-” para eliminar)________________

1. chattr +a file1 → permite escribir abriendo un fichero solamente modo append.

2. chattr +c file1 → permite que un fichero sea comprimido / descomprimido
automaticamente.

3. chattr +d file1 → asegura que el programa ignore borrar los ficheros durante la copia de
seguridad.

4. chattr +i file1 → convierte el fichero en inmutable o invariable, por lo que no puede ser
eliminado, alterado, renombrado, ni enlazado.

5. chattr +s file1 → permite que un fichero sea borrado de forma segura.
6. chattr +S file1 → asegura que un fichero sea modificado, los cambios son escritos en
modo synchronous como con sync.

7. chattr +u file1 → te permite recuperar el contenido de un fichero aún si este está
cancelado.

8. lsattr → mostrar atributos especiales.

 
___________________________________________________________________Archivos y ficheros comprimidos____________________________



1. 7za a -mx=9 -ms=on -mhe=on -p archivocomprimido directorio1 archivo1 archivo2 → comprimir
un directorio y dos archivos en formato 7zip, con compresión sólida máxima, y
protección por contraseña (la extensión 7z se agrega automáticamente).

2. 7za x archivocomprimido.7z → extraer un archivo comprimido en 7zip (7zip también
permite descomprimir otros formatos, como por ejemplo, zip).

3. bunzip2 file1.bz2 → descomprime in fichero llamado ‘file1.bz2′.
4. bzip2 file1 → comprime un fichero llamado ‘file1′.
5. gunzip file1.gz → descomprime un fichero llamado ‘file1.gz’.
6. gzip file1 → comprime un fichero llamado ‘file1′.
7. gzip -9 file1 → comprime con compresión máxima.
8. rar a file1.rar test_file → crear un fichero rar llamado ‘file1.rar’.
9. rar a file1.rar file1 file2 dir1 → comprimir ‘file1′, ‘file2′ y ‘dir1′ simultáneamente.
10.rar x file1.rar → descomprimir archivo rar.
11.unrar x file1.rar → descomprimir archivo rar.
12.tar -cvf archive.tar file1 → crear un tarball descomprimido.
13.tar -cvf archive.tar file1 file2 dir1 → crear un archivo conteniendo ‘file1′, ‘file2′ y’dir1′.
14.tar -tf archive.tar → mostrar los contenidos de un archivo.
15.tar -xvf archive.tar → extraer un tarball (si el archivo además está comprimido con gzip,
bzip2 o xz, descomprimirlo automáticamente).

16.tar -xvf archive.tar -C /tmp → extraer un tarball en /tmp.
17.tar -cjvf archive.tar.bz2 dir1 → crear un tarball comprimido en bzip2.
18.tar -xjvf archive.tar.bz2 → descomprimir un archivo tar comprimido en bzip2
19.tar -cJvf archive.tar.xz dir1 → crear un tarball comprimido en xz.
20.XZ_OPT=-9e tar -cJvf archive.tar.xz dir1 → crear un tarball comprimido en xz (con máxima
compresión).

21.tar -xJvf archive.tar.xz → descomprimir un archivo tar comprimido en xz.
22.tar -czvf archive.tar.gz dir1 → crear un tarball comprimido en gzip.
23.GZIP=-9 tar -czvf archive.tar.gz dir1 → crear un tarball comprimido en gzip (con máxima
compresión).

24.tar -xzvf archive.tar.gz → descomprimir un archive tar comprimido en gzip.
25.zip file1.zip file1 → crear un archivo comprimido en zip.
26.zip -r file1.zip file1 file2 dir1 → comprimir, en zip, varios archivos y directorios de forma
simultánea.

27.unzip file1.zip → descomprimir un archivo zip.

28.xz -d file.xz

 
____________________________________________________________________Paquetes rpm (Red Hat, Fedora y similares)_________________




1. rpm -ivh package.rpm → instalar un paquete rpm.
2. rpm -ivh --nodeeps package.rpm → instalar un paquete rpm ignorando las peticiones de
dependencias.

3. rpm -U package.rpm → actualizar un paquete rpm sin cambiar la configuración de los
ficheros.

4. rpm -F package.rpm → actualizar un paquete rpm solamente si este está instalado.
5. rpm -e package_name.rpm → eliminar un paquete rpm.
6. rpm -qa → mostrar todos los paquetes rpm instalados en el sistema.
7. rpm -qa | grep httpd → mostrar todos los paquetes rpm con el nombre “httpd”.
8. rpm -qi package_name → obtener información en un paquete específico instalado.
9. rpm -qg “System Environment/Daemons” → mostar los paquetes rpm de un grupo software.
10.rpm -ql package_name → mostrar lista de ficheros dados por un paquete rpm instalado.
11.rpm -qc package_name → mostrar lista de configuración de ficheros dados por un paquete
rpm instalado.

12.rpm -q package_name --whatrequires → mostrar lista de dependencias solicitada para un
paquete rpm.

13.rpm -q package_name --whatprovides → mostar la capacidad dada por un paquete rpm.
14.rpm -q package_name --scripts → mostrar los scripts comenzados durante la instalación
/eliminación.

15.rpm -q package_name --changelog → mostar el historial de revisions de un paquete rpm.
16.rpm -qf /etc/httpd/conf/httpd.conf → verificar cuál paquete rpm pertenece a un fichero dado.
17.rpm -qp package.rpm -l → mostrar lista de ficheros dados por un paquete rpm que aún no
ha sido instalado.

18.rpm --import /media/cdrom/RPM-GPG-KEY → importar la firma digital de la llave pública.
19.rpm --checksig package.rpm → verificar la integridad de un paquete rpm.
20.rpm -qa gpg-pubkey → verificar la integridad de todos los paquetes rpm instalados.
21.rpm -V package_name → chequear el tamaño del fichero, licencias, tipos, dueño, grupo,
chequeo de resumen de MD5 y última modificación.

22.rpm -Va → chequear todos los paquetes rpm instalados en el sistema. Usar con cuidado.
23.rpm -Vp package.rpm → verificar un paquete rpm no instalado todavía.
24.rpm2cpio package.rpm | cpio --extract --make-directories *bin → extraer fichero ejecutable
desde un paquete rpm.

25.rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm → instalar un paquete construido desde
una fuente rpm.

26.rpmbuild --rebuild package_name.src.rpm → construir un paquete rpm desde una fuente rpm.

27.cat /var/log/dpkg.log | grep "status installed"     → ver paquetes instalados con apt-get
28.cat /var/log/aptitude | grep "\[INSTALA\]"          → ver paquetes instalados con aptitude

 
_____________________________________________________________Actualizador de paquetes yum (Fedora, Redhat y otros)_____________




1. yum install package_name → descargar e instalar un paquete rpm.
2. yum localinstall package_name.rpm → este instalará un RPM y tratará de resolver todas las
dependencies para ti, usando tus repositorios.

3. yum update package_name.rpm → actualizar todos los paquetes rpm instalados en el sistema.
4. yum update package_name → modernizar / actualizar un paquete rpm.
5. yum remove package_name → eliminar un paquete rpm.
6. yum list → listar todos los paquetes instalados en el sistema.
7. yum search package_name → Encontrar un paquete en repositorio rpm.
8. yum clean packages → limpiar un caché rpm borrando los paquetes descargados.
9. yum clean headers → eliminar todos los ficheros de encabezamiento que el sistema usa para resolver la dependencia.
10.yum clean all → eliminar desde los paquetes caché y ficheros de encabezado.

_______________________________________________________Paquetes deb (Debian, Ubuntu y otros)___________________________________

1. dpkg -i package.deb → instalar / actualizar un paquete deb.
2. dpkg -r package_name → eliminar un paquete deb del sistema.
3. dpkg -l → mostrar todos los paquetes deb instalados en el sistema.
4. dpkg -l | grep httpd → mostrar todos los paquetes deb con el nombre “httpd”
5. dpkg -s package_name → obtener información en un paquete específico instalado en el sistema.
6. dpkg -L package_name → mostar lista de ficheros dados por un paquete instalado en el sistema.
7. dpkg --contents package.deb → mostrar lista de ficheros dados por un paquete no instalado todavía.
8. dpkg -S /bin/ping → verificar cuál paquete pertenece a un fichero dado. 



________________________________________________________Actualizador de paquetes apt (Debian, Ubuntu y otros)__________________


1. apt-get install package_name → instalar / actualizar un paquete deb.
2. apt-cdrom install package_name → instalar / actualizar un paquete deb desde un cdrom.
3. apt-get update → actualizar la lista de paquetes.
4. apt-get upgrade → actualizar todos los paquetes instalados.
5. apt-get remove package_name → eliminar un paquete deb del sistema.
6. apt-get check → verificar la correcta resolución de las dependencias.
7. apt-get clean → limpiar cache desde los paquetes descargados.
8. apt-cache search searched-package → retorna lista de paquetes que corresponde a la serie «paquetes buscados».
9. apt-cache show <paquete>  → muestra una descripcion completa del paquete


____________________________________________________________Ver el contenido de un fichero_____________________________________


1. cat file1 → ver los contenidos de un fichero comenzando desde la primera hilera.
2. cat file1 → ver los contenidos de un fichero comenzando desde la última línea.
3. more file1 → ver el contenido a lo largo de un fichero.
4. less file1 → parecido al commando ‘more’ pero permite salvar el movimiento en elfichero así como el movimiento hacia atrás.
5. head -2 file1 → ver las dos primeras líneas de un fichero.
6. tail -2 file1 → ver las dos últimas líneas de un fichero.
7. tail -f /var/log/messages → ver en tiempo real qué ha sido añadido al fichero.



____________________________________________________________Manipulación de texto______________________________________________

1. cat file1 file2 … | command <> file1_in.txt_or_file1_out.txt → sintaxis general para la
manipulación de texto utilizando PIPE, STDIN y STDOUT.

2. cat file1 | command( sed, grep, awk, grep, etc…) > result.txt → sintaxis general para manipular
un texto de un fichero y escribir el resultado en un fichero nuevo.

3. cat file1 | command( sed, grep, awk, grep, etc…) » result.txt → sintaxis general para manipular
un texto de un fichero y añadir resultado en un fichero existente.

4. grep Aug /var/log/messages → buscar palabras “Aug” en el fichero ‘/var/log/messages’.
5. grep ^Aug /var/log/messages → buscar palabras que comienzan con “Aug” en fichero
‘/var/log/messages’

6. grep [0-9] /var/log/messages → seleccionar todas las líneas del fichero ‘/var/log/messages’
que contienen números.

7. grep Aug -R /var/log/ → buscar la cadena “Aug” en el directorio ‘/var/log’ y debajo.
8. sed 's/string1/string2/g' ejemplo.txt → reemplazar en ejemplo.txt todas las ocurrencias de
“string1” con “string2”

9. sed '/^$/d' ejemplo.txt → eliminar todas las líneas en blanco desde el ejemplo.txt
10.sed '/ *#/d; /^$/d' ejemplo.txt → eliminar comentarios y líneas en blanco de ejemplo.txt
11.echo 'ejemplo' | tr '[:lower:]' '[:upper:]‘ → convertir “ejemplo” de minúsculas a mayúsculas.
12.sed -e '1d' ejemplo.txt → elimina la primera línea del fichero ejemplo.txt
13.sed -n '/string1/p‘ → visualizar solamente las líneas que contienen la palabra “string1”.
14.sed s/mysql/MySQL/g <FILEORIGIN> > <FILEDEST> → busca la palabra mysql (minuscula) y la reemplaza con MYSQL (mayuscula)
15.sed -i 's/\. */. /g'  → reemplaza todas las instancias con varios espacios seguidos por un numero por un espacio simple en todos los archivos de un directorio



     
____________________________________________Establecer caracter y conversión de ficheros_______________________________________



1. dos2unix filedos.txt fileunix.txt → convertir un formato de fichero texto desde MSDOS a
UNIX.

2. unix2dos fileunix.txt filedos.txt → convertir un formato de fichero de texto desde UNIX a
MSDOS.

3. recode ..HTML < page.txt > page.html → convertir un fichero de texto en html.
4. recode -l | more → mostrar todas las conversiones de formato disponibles.

 

___________________________________________________________Análisis del sistema de ficheros___________________________________



1. badblocks -v /dev/hda1 → Chequear los bloques defectuosos en el disco hda1.
2. fsck /dev/hda1 → reparar / chequear la integridad del fichero del sistema Linux en el disco
hda1.

3. fsck.ext2 /dev/hda1 → reparar / chequear la integridad del fichero del sistema ext 2 en el
disco hda1.

4. e2fsck /dev/hda1 → reparar / chequear la integridad del fichero del sistema ext 2 en el
disco hda1.

5. e2fsck -j /dev/hda1 → reparar / chequear la integridad del fichero del sistema ext 3 en el
disco hda1.

6. fsck.ext3 /dev/hda1 → reparar / chequear la integridad del fichero del sistema ext 3 en el
disco hda1.

7. fsck.vfat /dev/hda1 → reparar / chequear la integridad del fichero sistema fat en el disco
hda1.

8. fsck.msdos /dev/hda1 → reparar / chequear la integridad de un fichero del sistema dos en
el disco hda1.

9. dosfsck /dev/hda1 → reparar / chequear la integridad de un fichero del sistema dos en el
disco hda1.



_______________________________________________________________Formatear un sistema de ficheros______________________________



1. mkfs /dev/hda1 → crear un fichero de sistema tipo Linux en la partición hda1.

2. mke2fs /dev/hda1 → crear un fichero de sistema tipo Linux ext 2 en hda1.
3. mke2fs -j /dev/hda1 → crear un fichero de sistema tipo Linux ext3 (periódico) en la
partición hda1.

4. mkfs -t vfat 32 -F /dev/hda1 → crear un fichero de sistema FAT32 en hda1.
5. fdformat -n /dev/fd0 → formatear un disco flooply.
6. mkswap /dev/hda3 → crear un fichero de sistema swap.



   
___________________________________________________________Partición de sistema swap________________________________________


1.#mkswap /dev/hda3 → crear fichero de sistema swap.
2.#swapon /dev/hda3 → activando una nueva partición swap.
3.#swapon /dev/hda2 /dev/hdb3 → activar dos particiones swap.




_____________________________________________________________________Salvas________________________________________________


1.#dump -0aj -f /tmp/home0.bak /home → hacer una salva completa del directorio ‘/home’.
2.#dump -1aj -f /tmp/home0.bak /home → hacer una salva incremental del directorio ‘/home’.
3.#restore -if /tmp/home0.bak → restaurando una salva interactivamente.
4.#rsync -rogpav --delete /home /tmp → sincronización entre directorios.
5.#rsync -rogpav -e ssh --delete /home ip_address:/tmp → rsync a través del túnel SSH.
6.#rsync -az -e ssh --delete ip_addr:/home/public /home/local → sincronizar un directorio local con
un directorio remoto a través de ssh y de compresión.

7.#rsync -az -e ssh --delete /home/local ip_addr:/home/public → sincronizar un directorio remoto
con un directorio local a través de ssh y de compresión.

8.#dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz‘ → hacer una salva de un disco duro en un host remoto a través de ssh.
9.#dd if=/dev/sda of=/tmp/file1 → salvar el contenido de un disco duro a un fichero. (En este
caso el disco duro es “sda” y el fichero “file1”).

10.#tar -Puf backup.tar /home/user → hacer una salva incremental del directorio ‘/home/user’.
11.#tar -czv --exclude=/root/dir1/* -f /var/salvas/cfg_$(date +%F_%H%M).tgz /etc /root → salvar los 
directorios /etc y /root (excluyendo el contenido del subdirectorio /root/dir1/) en un
archivo comprimido, cuyo nombre contenga la fecha y hora actual.

12.#( cd /tmp/local/ && tar c . ) | ssh -C user@ip_addr 'cd /home/share/ && tar x -p‘ → copiar el 
contenido de un directorio en un directorio remoto a través de ssh.

13.#( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home && tar x -p‘ → copiar un directorio local en un directorio remoto a través de ssh.
14.#tar cf - . | (cd /tmp/backup ; tar xf - ) → copia local conservando las licencias y enlaces desde un directorio a otro.

15.#find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents →
encontrar y copiar todos los ficheros con extensión ‘.txt’ de un directorio a otro.

16.#find /var/log -name '*.log' | tar cv --files-from=- | bzip2 > log.tar.bz2 → encontrar todos los ficheros 
con extensión ‘.log’ y hacer un archivo bzip.

17.#dd if=/dev/hda of=/dev/fd0 bs=512 count=1      → hacer una copia del MRB (Master Boot Record) a un disco floppy.
18.#dd if=/dev/fd0 of=/dev/hda bs=512 count=1      → restaurar la copia del MBR (Master Boot Record) salvada en un floppy.
19.#history | awk '{print $2}' | awk 'BEGIN {FS="|"}{print $1}'   → ver comandos mas usados
20.#echo "" /var/log/auth.log                                     → limpiar auth log
21.#echo "" ~/.bash_history -rf                                   →limpiar bash history
22.#history -c                                                    →limpiar history sesion reciente
23.#export HISTSIZE=0                                             →configura en 0 el maximo de history lines
24.#unset HISTFILE                                                →deshabilitar history- desloguearse despues
25.#kill -9 $$                                                    →kill current session
26.#ln /dev/null ~/.bash_history -sf                              →envia todos los comandos de history a /dev/null
27.#history | tail -50                                            →ultimos 50 comandos
 
28.MEGATOOLS
28.a medadl --print-names 'link del archivo'      →descargamos archivos
28.b megaput *.zip 'link de la carpeta a la que subiremos los archivos'

  

______________________________________________________________________CDROM___________________________________________________



1. cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force → limpiar o borrar un cd
regrabable.

2. mkisofs /dev/cdrom > cd.iso → crear una imagen iso de cdrom en disco.
3. mkisofs /dev/cdrom | gzip > cd_iso.gz → crear una imagen comprimida iso de cdrom en
disco.

4. mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd→ crear una imagen
iso de un directorio.

5. cdrecord -v dev=/dev/cdrom cd.iso → quemar una imagen iso.
6. gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - → quemar una imagen iso comprimida.
7. mount -t udf,iso9660 -o loop cd.iso /mnt/iso → montar una imagen iso.
8. cd-paranoia -B → llevar canciones de un cd a ficheros wav.

 
9. cd-paranoia -- ”-3” → llevar las 3 primeras canciones de un cd a ficheros wav.
10.cdrecord --scanbus → escanear bus para identificar el canal scsi.
11.dd if=/dev/hdc | md5sum → hacer funcionar un md5sum en un dispositivo, como un CD.
12.eject -v → expulsar un medio o disco extraíble, ofreciendo información adicional.


    

______________________________________________________Trabajo con la red (LAN Y WIFI)_________________________________________



1.1) arhclinux
1.a) ip link      → listar interfaces de red
1.b) ip link show dev eth0
1.c) ip link set etrh0 up
1.d) systemctl start dhcpcd@eth0.service

1.2) centos
1.a) ip link show eth0
1.b) ip link set eth0 up
1.c) service network start
1.d) dhclient eht0

1.3) Configurar IP fija en centos:
1.a) #nano /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=none 
NM_CONTROLLED=no 
ONBOOT=yes
TYPE=Ethernet 
IPADDR=192.168.1.90 
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
1.b)reboot

1.4) Configurar Multiples Direcciones IPs en una Interfaz (DEBIAN)
From:https://www.linuxito.com/gnu-linux/nivel-medio/405-configurar-multiples-direcciones-ip-en-una-misma-interfaz-de-red-en-debian-y-centos

1.4.a) #nano /etc/network/interfaces

# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
allow-hotplug eth0
iface eth0 inet static
        address 10.10.150.1
        netmask 255.255.255.0
        network 10.10.150.0
        broadcast 10.10.150.255
        gateway 192.168.1.1
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers 8.8.8.8 8.8.4.4

allow-hotplug eth0:0
iface eth0:0 inet static
        address 10.10.151.1
        netmask 255.255.255.0
        network 10.10.151.0
        broadcast 10.10.151.255
1.4.b)ifup eth0:0
1.4.c)ifconfig     → Check and Enjoy tu nueva interfaz
 

1. iw dev       → listar interfaces de red
1. ifconfig eth0 → mostrar la configuración de una tarjeta de red Ethernet.
2. ifup eth0 → activar una interface ‘eth0′.
3. ifdown eth0 → deshabilitar una interface ‘eth0′.
4. ifconfig eth0 192.168.1.1 netmask 255.255.255.0 → configurar una dirección IP.
5. ifconfig eth0 promisc → configurar ‘eth0′en modo común para obtener los paquetes (sniffing).
6. dhclient eth0 → activar la interface ‘eth0′ en modo dhcp.
7. route -n → mostrar mesa de recorrido.
8. route add -net 0/0 gw IP_Gateway → configurar entrada predeterminada.
9. route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 → configurar ruta estática para 
buscar la red ’192.168.0.0/16′.

10.route del 0/0 gw IP_gateway → eliminar la ruta estática.
11.echo “1” > /proc/sys/net/ipv4/ip_forward → activar el recorrido ip.
12.hostname → mostrar el nombre del host del sistema.
13.host www.example.com → buscar el nombre del host para resolver el nombre a una dirección ip(1).
14.nslookup www.example.com → buscar el nombre del host para resolver el nombre a una direccióm ip y viceversa(2).

15.ip link show → mostar el estado de enlace de todas las interfaces.
16.mii-tool eth0 → mostar el estado de enlace de ‘eth0′.
17.ethtool eth0 → mostrar las estadísticas de tarjeta de red ‘eth0′.
18.netstat -tup → mostrar todas las conexiones de red activas y sus PID.
19.netstat -tupl → mostrar todos los servicios de escucha de red en el sistema y sus PID.
20.netstat -punta → mostrar todas las conexiones activas por dirección IP y puerto.
21.tcpdump tcp port 80 → mostrar todo el tráfico HTTP.
22.iwlist scan → mostrar las redes inalámbricas.
23.iwconfig eth1 → mostrar la configuración de una tarjeta de red inalámbrica.
24.whois www.example.com → buscar en base de datos Whois.
25.iftop -nNP -i eth0 → mostrar en tiempo real las conexiones abiertas en eth0 y su tasa de
transferencia.

26.sockstat → mostrar información sobre las conexiones abiertas.
27.arp-scan -l → descubrir en la red las direcciones IP y MAC.

Redireccionas trafico de una IP/puerto a otra IP/puerto
28.echo "1" >/proc/sys/net/ipv4/ip_forward o 28.sysctl net.ipv4.ip_froward=1
29.service networking restart o 29.service nertwork restart
Ahora pasaremos a lo importante, indicarle al servidor mediante iptables qué redireccionar:
30.iptables -t nat -A PREROUTING -p tcp --dport <puerto receptor> -j DNAT --to-destination <ip final>:<puerto de ip final>
Ej.iptables -t nat -A PREROUTING -p tcp --dport 110 -j DNAT --to-destination 10.10.0.2:110
"El servidor 10.10.0.2 verá que todos los paquetes o peticiones vienen desde la IP del cliente, en caso de que quieran 
natear las peticiones, o sea, que el 2do servidor vea que las peticiones llegan con la IP del 1er servidor 
(y en el cual aplicamos la redirección), sería poner además esta segunda línea:"
31.iptables -t nat -A POSTROUTING -j MASQUERADE

32.WPA supplicant

Sencillo:

Creamos un archivo de configuracion:
wlan0.conf en el que volcamos, basico, la siguiente estructura que podemos generar con wl siguiente comando:
# wpa_passphrase nombre-de-la-red frase-contraseña
network={
    ssid="nombre-de-la-red"
    #psk="frase-contraseña"
    psk=f5d1c49e15e679bebe385c37648d4141bc5c9297796a8a185d7bc5ac62f954e3
}
# wpa_supplicant -B -i interfaz -c archivo_de_configuración
# dhcpcd wlan0


Puente (desordene atomos)

#brctl   
#brctl addbr puente                     //nombre del puente 'puente'
#brctl addif puente at0
#brctl addif puente eth0                //con estos 2 comandos acabamos de unir las interfaces
#ip link set up dev bridge_name         //si fuera necesario levantar la interfaz puente (ARCH)
#ip link set dev bridge_name down       //si fuera necesario bajar la interfaz puente
#[dhcpcd | dhclient] puente
#brctl show
#brctl delbr bridge_name                //eliminar la interfaz puente

Virtual interface temporary

#ifconfig eth0:0
#ifconfig eth0:0 192.168.1.1
#ifconfig eth0:0 down            //disable virtual interface

Virtual interface permanent

DEBIAN 
#edit /etc/network/interfaces
iface eth0:0 inet static               //o iface eth0:0 inet dhcp 
address 123.123.22.22
netmask 255.0.0.0
broadcast 123.255.255.255
#/etc/init.d/networking restart

REDHAT/FEDORA/CENTOS
#in the directory /etc/sysconfig/network-scripts añadir un archivo correspondiente a la interfaz ej. ifcfg-eth0:0
DEVICE=eth0:0
IPADDR=123.123.22.22
NETMASK=255.0.0.0
NETWORK=123.0.0.0
BROADCAST=123.255.255.255
ONBOOT=yes
                           //or DHCP
DEVICE=eth0:0
BOOTPROTO=dhcp
ONBOOT=yes

#service network restart






